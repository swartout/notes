---
layout: default
title: CSE 351
parent: CSE
---

# CSE 351

---

## Lecture 1 - June 21

- We will cover three main topics:
    - Data
    - Programs
    - Scale
- The prefix for binary is: `0b`, hex prefix is: `0x`
- With $n$ binary digits we can represent $2^n$ things
    - With $n$ digits of base $b$ we can represent $b^n$ things
- ASCII characters are one byte, representing 256 characters
    - lol we have so much more memory now, hello UTF encoding

---

## Lecture 2 - June 23

- The CPU executes instructions which are also stored in memory
- CSE 351 is about data movement - how is memory stored or found?
- Base-2 is the default (although DNA/quantum computing is researched)
- We manipulate memory as chunks of bytes (even if it doesn't need all bits - hello bools!)
- Definition "word": a 8-byte chunk of memory
- x86-64 systems use 64-bit words
    - The potential address space is 2^64 addresses
- Pointers are also stored in memory like any other data
- Big-endian: least signifcant byte stored in the *largest* address
    - Not commonly used
- Little-endian: least significant byte stored in *smallest* address
    - x86, x86-64
- Bi-endian (used on ARM/M1)
- The pointer always points to the lowest address of the data

---

## Lecture 3 - June 26

- Pointers are defined: `type* ptr;`
    - The `type` encodes size information, the `*` designates it is a pointer
- To get the address of a variable, write: `type* ptr = &var;`
    - The address must be stored in a pointer
- The "dereference" operator `*` is used to "grab" the data a pointer points to
    - i.e. `int num = *ptr;`
- `NULL` is a special pointer to nothing
- Addition of a pointer and a scalar scales the scalar by the size of the type
- Subtraction of two pointers the value is scaled (divided) by the size of the type
    - We can use this to find the amount of `type`s between two pointers
- Arrays are sets of contiguous locations in memory that store the same type of data object
    - C declaration: `type name[size]`
    - Indexing actually works with: `*(array_name + n)`
- "Strings" in C are actually just arrays of chars terminated by the null character
    - i.e. `char str[] = "hi"` allocates an array of size three
    - Null character is backslash 0
        - not every array in C has this null character
- In C, declaration does *not* mean initialization: there can be garbage data

---

## Lecture 4 - June 28

- `0` is false, everything else is true
- Bitwise operators:
    - AND: `&`
    - OR:  `|`
    - XOR: `^`
    - NOT: `~`
- Logical operators:
    - AND: `&&`
    - OR:  `||`
    - NOT: `!`
- Unsigned integers work as expected
- Signed integers use: *Two's Complement*
    - The weight of the most significant bit is negative
    - This means `-x == ~x + 1`
- Bitmasking allows us to change our inputs as we want

---

## Lecture 5 - June 30

- Signed/unsigned integers are represented in memory the same way
- Type casting includes:
    - Changes in bit-widths
    - Changes in interpretation
    - Full changes in representations
- Implicit casting happens when there is a type mismatch, but a well defined conversion between the two types
- Explicit casts: `(new_type) expression`
- When casting between bit-widths, we must extend the data
    - Zero extension: padding with extra zeros on the left (preserves the value)
    - Sign extension: pad signed data with copies on most signficant bit (preserves sign and value)
- Operations between signed and unsigned values implicitly cast all values to unsigned representations
- Fixed-with binary arithmatic is modular
    - This results in integer overflow
- Bit shifting: move all bits a specified amount in a direction, filling in what is lost
    - Left shift: `x << n` fills in `n` zeros on the right
    - Logical right shift: `x >> n` where `x` is unsigned, fills in zeros on the left
    - Arithmetic right shift: `x >> n` where `x` is signed, fills in with copies of most significant bit on the left
- Bit shifting can be interpreted as integer multiplication or division by powers of two
- To force unsigned ints, we must append number with `u` or `U`
